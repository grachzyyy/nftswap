"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Driver = void 0;
const options_1 = require("./options");
const detector_1 = require("../detectors/detector");
const config_1 = require("../internals/config");
const context_1 = require("../internals/context");
const exceptions_1 = require("../internals/exceptions");
const builders_1 = require("../internals/ir/builders/");
const imports_1 = require("../internals/ir/builders/imports");
const logger_1 = require("../internals/logger");
const tact_1 = require("../internals/tact");
const util_1 = require("../internals/util");
const warnings_1 = require("../internals/warnings");
const tool_1 = require("../tools/tool");
const ignore_1 = __importDefault(require("ignore"));
const json_bigint_1 = __importDefault(require("json-bigint"));
const path_1 = __importDefault(require("path"));
/**
 * Manages the initialization and execution of detectors for analyzing compilation units.
 */
class Driver {
    ctx;
    detectors = [];
    tools = [];
    outputPath;
    /** List of detectors explicitly disabled by the user. */
    disabledDetectors;
    colorizeOutput;
    fs;
    /**
     * Compilation units representing the actual entrypoints of the analysis targets
     * based on user's input. Might be empty if no paths are specified.
     */
    cus;
    /** Minimum severity level to report warnings. */
    minSeverity;
    outputFormat;
    constructor(tactPaths, options) {
        this.fs = options.fs;
        this.ctx = new context_1.MistiContext(options);
        this.cus = this.createCUs(tactPaths);
        this.disabledDetectors = new Set(options.disabledDetectors ?? []);
        this.colorizeOutput = options.colors;
        this.minSeverity = options.minSeverity;
        this.outputFormat = options.outputFormat;
        this.outputPath = options.outputPath;
    }
    /**
     * Asynchronously creates a driver initializing all detectors.
     * @param tactPath Path to the Tact project configuration of to a single Tact contract.
     */
    static async create(tactPaths, options = {}) {
        const mergedOptions = { ...options_1.cliOptionDefaults, ...options };
        this.checkCLIOptions(mergedOptions);
        const driver = new Driver(tactPaths, mergedOptions);
        await driver.initializeDetectors();
        await driver.initializeTools();
        if (mergedOptions.souffle && !driver.ctx.souffleAvailable) {
            this.warnOnDisabledDetectors(driver);
        }
        return driver;
    }
    /**
     * Resolves the filepaths provided as an input to Misti to initialize the
     * compilation units which are IR entries to target analysis on.
     *
     * @param tactPaths Paths received from the user.
     * @returns Created compilation units.
     */
    createCUs(tactPaths) {
        return [...new Set(tactPaths)]
            .reduce((acc, tactPath) => {
            if (this.fs.stat(tactPath).isDirectory()) {
                const tactFiles = this.collectTactFiles(tactPath);
                this.ctx.logger.debug(`Collected Tact files from ${tactPath}:\n${tactFiles.map((tactFile) => "- " + tactFile).join("\n")}`);
                acc.push(...tactFiles);
            }
            else {
                acc.push(tactPath);
            }
            return acc;
        }, [])
            .filter((tactPath) => this.fs.exists(tactPath) ||
            (this.ctx.logger.error(`${tactPath} is not available`), false))
            .reduce((acc, tactPath) => {
            // TODO: Check on the available import graphs if some of the inputs are already added
            let importGraph;
            let configManager;
            if (tactPath.endsWith(".tact")) {
                importGraph = imports_1.ImportGraphBuilder.make(this.ctx, [tactPath]).build();
                let projectRoot = importGraph.resolveProjectRoot(this.fs);
                if (projectRoot === undefined) {
                    projectRoot = path_1.default.dirname(tactPath);
                    this.ctx.logger.warn(`Cannot resolve project path. Trying ${projectRoot}`);
                }
                const projectName = path_1.default.basename(tactPath, ".tact");
                // TODO: Try to merge them into one of the existing configs.
                configManager = tact_1.TactConfigManager.fromContract(projectRoot, tactPath, projectName, this.fs);
                const projectConfig = configManager.findProjectByName(projectName);
                if (projectConfig === undefined) {
                    throw exceptions_1.InternalException.make([
                        `Cannot find ${projectName} in the configuration file generated for ${tactPath}:`,
                        JSON.stringify(configManager.getConfig, null, 2),
                    ].join("\n"));
                }
                const ast = (0, tact_1.parseTactProject)(this.ctx, projectConfig, projectRoot, this.fs);
                const cu = (0, builders_1.createIR)(this.ctx, projectName, ast, importGraph);
                acc.set(projectName, cu);
            }
            else {
                // Tact configuration file
                configManager = tact_1.TactConfigManager.fromConfig(tactPath);
                importGraph = imports_1.ImportGraphBuilder.make(this.ctx, configManager.getEntryPoints()).build();
                configManager.getProjects().forEach((configProject) => {
                    const ast = (0, tact_1.parseTactProject)(this.ctx, configProject, configManager.getProjectRoot(), this.fs);
                    const projectName = configProject.name;
                    const cu = (0, builders_1.createIR)(this.ctx, projectName, ast, importGraph);
                    acc.set(projectName, cu);
                });
            }
            return acc;
        }, new Map());
    }
    /**
     * Collects all the .tact files in the given directory with respect to ignore heuristics.
     * @param dir The directory to search in.
     * @returns The list of .tact files.
     */
    collectTactFiles(dir) {
        let results = [];
        const files = this.fs.readdir(dir);
        // If .gitignore exists, use it to ignore files
        const gitignorePath = findGitignore(dir, this.fs);
        let ig = (0, ignore_1.default)();
        if (gitignorePath) {
            ig = (0, ignore_1.default)().add(this.fs.readFile(gitignorePath).toString("utf8"));
        }
        files.forEach((file) => {
            const fullPath = path_1.default.join(dir, file);
            const relativePath = path_1.default.relative(dir, fullPath);
            if (!ig.ignores(relativePath) && !fullPath.includes("node_modules")) {
                if (this.fs.stat(fullPath).isDirectory()) {
                    results = results.concat(this.collectTactFiles(fullPath));
                }
                else if (file.endsWith(".tact")) {
                    results.push(fullPath);
                }
            }
        });
        return results;
    }
    /**
     * Check CLI options for ambiguities.
     * @throws If Misti cannot be executed with the given options
     */
    static checkCLIOptions(options) {
        if (options.verbose === true && options.quiet === true) {
            throw exceptions_1.ExecutionException.make(`Please choose only one option: --verbose or --quiet`);
        }
        if (options.allDetectors === true &&
            options.enabledDetectors !== undefined) {
            throw exceptions_1.ExecutionException.make(`--enabled-detectors and --all-detectors cannot be used simultaneously`);
        }
        // Check for duplicate tool class names
        if (options.tools && options.tools.length > 0) {
            const toolClassNames = options.tools.map((tool) => tool.className);
            const uniqueClassNames = new Set(toolClassNames);
            if (toolClassNames.length !== uniqueClassNames.size) {
                const duplicates = toolClassNames.filter((name, index) => toolClassNames.indexOf(name) !== index);
                throw exceptions_1.ExecutionException.make(`Duplicate tool class names found: ${duplicates.join(", ")}. Each tool must have a unique class name.`);
            }
        }
        // Check for intersection between enabledDetectors and disabledDetectors
        if (options.enabledDetectors && options.disabledDetectors) {
            const enabledSet = new Set(options.enabledDetectors);
            const disabledSet = new Set(options.disabledDetectors);
            const intersection = [...enabledSet].filter((x) => disabledSet.has(x));
            if (intersection.length > 0) {
                throw exceptions_1.ExecutionException.make(`Detectors cannot be both enabled and disabled. Conflicting detectors: ${intersection.join(", ")}`);
            }
        }
    }
    /**
     * Warns the user about the Soufflé detectors that were disabled due to missing Soufflé installation.
     */
    static warnOnDisabledDetectors(driver) {
        const disabled = driver.detectors.reduce((acc, detector) => {
            if (detector.usesSouffle) {
                acc.push(`* ${detector.id}`);
            }
            return acc;
        }, []);
        if (disabled.length === 0) {
            return;
        }
        driver.ctx.logger.warn([
            "No Soufflé installation found. The following detectors will be disabled:",
            disabled.join("\n"),
            "Please install Soufflé according to the installation instructions to enable them: https://souffle-lang.github.io/install",
        ].join("\n"));
    }
    /**
     * Initializes all detectors specified in the configuration including external and built-in detectors.
     * @throws Error if a detector class cannot be found in the specified module or as a built-in.
     */
    async initializeDetectors() {
        const detectorPromises = this.ctx.config.detectors.reduce((acc, config) => {
            if (this.disabledDetectors.has(config.className)) {
                this.ctx.logger.debug(`Suppressed detector: ${config.className}`);
                return acc;
            }
            acc.push((async () => {
                var _a;
                let DetectorClass;
                if (config.modulePath) {
                    let module;
                    try {
                        const absolutePath = path_1.default.resolve(config.modulePath);
                        const relativePath = path_1.default.relative(__dirname, absolutePath);
                        module = await (_a = relativePath.replace(path_1.default.extname(relativePath), ""), Promise.resolve().then(() => __importStar(require(_a))));
                        DetectorClass = module[config.className];
                    }
                    catch (error) {
                        this.ctx.logger.error(`Failed to import module: ${config.modulePath}`);
                        this.ctx.logger.error(`${error}`);
                        return null;
                    }
                }
                else {
                    const detector = await (0, detector_1.findBuiltInDetector)(this.ctx, config.className);
                    if (!detector) {
                        throw exceptions_1.ExecutionException.make(`Built-in detector ${config.className} not found`);
                    }
                    return detector;
                }
                if (!DetectorClass) {
                    throw exceptions_1.ExecutionException.make(`Detector class ${config.className} not found in module ${config.modulePath}`);
                }
                if (DetectorClass.maxSeverity < this.minSeverity) {
                    this.ctx.logger.debug(`Skipping detector ${config.className} - max severity ${DetectorClass.maxSeverity} < min severity ${this.minSeverity}`);
                    return null;
                }
                return new DetectorClass(this.ctx);
            })());
            return acc;
        }, []);
        this.detectors = (await Promise.all(detectorPromises)).filter((detector) => detector !== null);
        this.ctx.logger.debug(`Enabled detectors (${this.detectors.length}): ${this.detectors.map((d) => d.id).join(", ")}`);
    }
    /**
     * Initializes all built-in tools specified in the configuration.
     * @throws Error if a tool cannot be found or initialized.
     */
    async initializeTools() {
        const toolPromises = this.ctx.config.tools.map(async (config) => {
            const tool = await (0, tool_1.findBuiltInTool)(this.ctx, config.className, config.options || {});
            if (!tool) {
                throw exceptions_1.ExecutionException.make(`Built-in tool ${config.className} not found`);
            }
            return tool;
        });
        this.tools = await Promise.all(toolPromises);
        this.ctx.logger.debug(`Enabled tools (${this.tools.length}): ${this.tools.map((t) => t.id).join(", ")}`);
    }
    /**
     * Actual implementation of the entry point.
     */
    async executeImpl() {
        if (this.detectors.length === 0 && this.tools.length === 0) {
            this.ctx.logger.warn("Nothing to execute. Please specify at least one detector or tool.");
            return { kind: "ok" };
        }
        try {
            return this.tools.length > 0
                ? await this.executeTools()
                : await this.executeAnalysis();
        }
        catch (err) {
            const result = [];
            if (err instanceof Error) {
                result.push(err.message);
                if (err.stack !== undefined && config_1.MistiEnv.MISTI_TRACE) {
                    result.push(err.stack);
                }
            }
            else {
                result.push(`An error occurred:\n${json_bigint_1.default.stringify(err)}`);
            }
            const error = result.join("\n");
            new logger_1.Logger().error(error);
            return { kind: "error", error };
        }
    }
    /**
     * Wraps the entry point of execution with extra logging handling logic.
     */
    async execute() {
        const result = await this.executeImpl();
        if (this.outputFormat === "json") {
            return {
                ...result,
                logs: this.ctx.logger.getJsonLogs(),
            };
        }
        return result;
    }
    /**
     * Executes all the initialized detectors on the compilation units.
     * @param cus Map of compilation units
     * @returns MistiResult containing detectors output
     */
    async executeAnalysis() {
        const allWarnings = await (async () => {
            const warningsMap = new Map();
            await Promise.all(Array.from(this.cus.entries()).map(async ([projectName, cu]) => {
                const warnings = await this.checkCU(cu);
                warningsMap.set(projectName, warnings);
            }));
            return warningsMap;
        })();
        const filteredWarnings = this.filterImportedWarnings(Array.from(this.cus.keys()), allWarnings);
        this.filterSuppressedWarnings(filteredWarnings);
        const reported = new Set();
        let foundWarnings = false;
        const warnings = [];
        for (const [_, projectWarnings] of filteredWarnings.entries()) {
            projectWarnings.forEach((warn) => {
                const hash = (0, warnings_1.hashWarning)(warn);
                if (!reported.has(hash) && warn.severity >= this.minSeverity) {
                    warnings.push(warn);
                    foundWarnings = true;
                    reported.add(hash);
                }
            });
        }
        warnings.sort((a, b) => b.severity - a.severity);
        return foundWarnings
            ? {
                kind: "warnings",
                warnings,
            }
            : { kind: "ok" };
    }
    /**
     * Executes all the initialized tools on the compilation units.
     * @returns MistiResult containing tool outputs
     */
    async executeTools() {
        const standaloneTools = this.tools.filter((tool) => tool_1.Tool.canRunStandalone(tool));
        const cuDependentTools = this.tools.filter((tool) => !tool_1.Tool.canRunStandalone(tool));
        const standaloneOutputs = await Promise.all(standaloneTools.map((tool) => {
            try {
                return tool.runStandalone();
            }
            catch (error) {
                this.ctx.logger.error(`Error executing standalone tool ${tool.id}: ${error}`);
                return null;
            }
        }));
        const cuOutputs = await Promise.all(Array.from(this.cus.values()).flatMap((cu) => cuDependentTools.map((tool) => {
            try {
                return tool.run(cu);
            }
            catch (error) {
                this.ctx.logger.error(`Error executing tool ${tool.id}: ${error}`);
                return null;
            }
        })));
        const allOutputs = [...standaloneOutputs, ...cuOutputs];
        return {
            kind: "tool",
            output: allOutputs.filter((output) => output !== null),
        };
    }
    /**
     * Finds detector with a given name among the detectors available within the project.
     * @throws If not found
     */
    findDetector(name) {
        return this.detectors.find((d) => d.id === name);
    }
    /**
     * Filters warnings from multi-file projects detectors with respect to `WarningsBehavior`.
     */
    filterImportedWarnings(allProjectNames, allWarnings) {
        // Early exit if there are no any detectors with the `intersect` behavior
        if (this.detectors.filter((d) => d.shareImportedWarnings === "intersect")
            .length === 0) {
            return allWarnings;
        }
        // A mapping from warning messages to projects it has been reported.
        const warningsMap = new Map();
        allWarnings.forEach((warnings, projectName) => {
            warnings.forEach((warn) => {
                const hash = (0, warnings_1.hashWarning)(warn);
                if (!warningsMap.has(hash)) {
                    warningsMap.set(hash, []);
                }
                warningsMap.get(hash).push(projectName);
            });
        });
        const filteredWarnings = new Map();
        for (const [projectName, warnings] of allWarnings) {
            const projectWarnings = [];
            for (const warn of warnings) {
                const behavior = this.findDetector(warn.detectorId).shareImportedWarnings;
                switch (behavior) {
                    case "intersect":
                        // The warning must be raised in all the projects.
                        const projects = warningsMap.get((0, warnings_1.hashWarning)(warn));
                        if (new Set(allProjectNames).size === new Set(projects).size &&
                            [...new Set(allProjectNames)].every((value) => new Set(projects).has(value))) {
                            projectWarnings.push(warn);
                        }
                        break;
                    case "union":
                        // Add everything
                        projectWarnings.push(warn);
                        break;
                    default:
                        (0, util_1.unreachable)(behavior);
                }
            }
            filteredWarnings.set(projectName, projectWarnings);
        }
        return filteredWarnings;
    }
    /**
     * Filters out the suppressed warnings.
     * Mutates the input map removing suppressed warnings.
     */
    filterSuppressedWarnings(warnings) {
        this.filterSuppressedInAnnotations(warnings);
        this.filterSuppressedInConfig(warnings);
    }
    /**
     * Filters out the warnings suppressed in the code annotations.
     * Mutates the input map removing suppressed warnings.
     */
    filterSuppressedInAnnotations(warnings) {
        warnings.forEach((projectWarnings, projectName) => {
            const filteredWarnings = projectWarnings.filter((warning) => !warning.suppressed);
            warnings.set(projectName, filteredWarnings);
        });
    }
    /**
     * Compares suppressionFile and warningFile.
     * If suppressionFile is an absolute path, returns true if the files are the same after normalization.
     * If suppressionFile is relative, returns true if warningFile ends with the normalized relative path.
     */
    pathsAreEqual(suppressionFile, warningFile) {
        const normalizedWarningFile = path_1.default.normalize(warningFile);
        const normalizedSuppressionFile = path_1.default.normalize(suppressionFile);
        // Special handling for test environments
        if ((0, util_1.isTest)() && !path_1.default.isAbsolute(warningFile)) {
            const absoluteWarningFile = path_1.default.join(process.cwd(), normalizedWarningFile);
            return this.pathsAreEqual(suppressionFile, absoluteWarningFile);
        }
        return path_1.default.isAbsolute(suppressionFile)
            ? normalizedWarningFile === normalizedSuppressionFile
            : normalizedWarningFile.endsWith(normalizedSuppressionFile);
    }
    /**
     * Checks if a warning matches suppression.
     */
    suppressionMatchesWarning(suppression, warning) {
        if (!warning.location.file)
            return false;
        if (warning.location.line !== suppression.line ||
            warning.location.column !== suppression.col) {
            return false;
        }
        return this.pathsAreEqual(suppression.file, warning.location.file);
    }
    /**
     * Filters warnings suppressed in the config file.
     * Mutates the input map, removing suppressed warnings.
     */
    filterSuppressedInConfig(warnings) {
        this.ctx.config.suppressions.forEach((suppression) => {
            let suppressionUsed = false;
            warnings.forEach((projectWarnings, projectName) => {
                const filteredWarnings = projectWarnings.filter((warning) => {
                    if (this.suppressionMatchesWarning(suppression, warning)) {
                        suppressionUsed = true;
                        return false;
                    }
                    return true;
                });
                warnings.set(projectName, filteredWarnings);
            });
            if (!suppressionUsed) {
                this.ctx.logger.warn(`Unused suppression: ${suppression.detector} at ${suppression.file}:${suppression.line}:${suppression.col}`);
            }
        });
    }
    /**
     * Executes all detectors on a given compilation unit and collects any warnings found.
     * @param cu The compilation unit to check.
     * @returns Warnings generated by each of detectors.
     */
    async checkCU(cu) {
        const warningsPromises = this.detectors.map(async (detector) => {
            if (!this.ctx.souffleAvailable && detector.usesSouffle) {
                this.ctx.logger.debug(`${cu.projectName}: Skipping ${detector.id} since no Soufflé installation is available`);
                return [];
            }
            return this.ctx.logger.withContext(`${detector.id}:${cu.projectName}`)(async () => {
                this.ctx.logger.debug(`Running detector for ${cu.projectName}`);
                try {
                    // Conditional import for setTimeout to support both Node.js and browser environments
                    let setTimeoutPromise;
                    if ((0, util_1.isBrowser)()) {
                        setTimeoutPromise = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
                    }
                    else {
                        setTimeoutPromise = (await Promise.resolve().then(() => __importStar(require("timers/promises")))).setTimeout;
                    }
                    const warnings = await Promise.race([
                        detector.check(cu),
                        setTimeoutPromise(config_1.MistiEnv.MISTI_TIMEOUT, []).then(() => {
                            throw new Error(`Detector ${detector.id} timed out after ${config_1.MistiEnv.MISTI_TIMEOUT}ms`);
                        }),
                    ]);
                    this.ctx.logger.debug(`Finished detector`);
                    return warnings;
                }
                catch (err) {
                    let error = "";
                    if (err instanceof Error) {
                        const result = [];
                        result.push(err.message);
                        if (err.stack !== undefined &&
                            this.ctx.config.verbosity === "debug") {
                            result.push(err.stack);
                        }
                        error = result.join("\n");
                    }
                    else {
                        error = `${err}`;
                    }
                    this.ctx.logger.error(`Error in detector: ${error}`);
                    return [];
                }
            });
        });
        try {
            return (await Promise.all(warningsPromises)).flat();
        }
        catch (error) {
            throw exceptions_1.InternalException.make(`${cu.projectName} execution error:\n${error}`);
        }
    }
}
exports.Driver = Driver;
/**
 * Finds the .gitignore file in the given directory or any of its parent directories.
 * @param startDir The directory to start searching from.
 * @returns The path to the .gitignore file or null if not found.
 */
function findGitignore(startDir, fs) {
    let currentDir = startDir;
    while (currentDir !== path_1.default.parse(currentDir).root) {
        const gitignorePath = path_1.default.join(currentDir, ".gitignore");
        if (fs.exists(gitignorePath)) {
            return gitignorePath;
        }
        currentDir = path_1.default.dirname(currentDir);
    }
    return null;
}
